var documenterSearchIndex = {"docs":
[{"location":"lib/internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"Documentation for DelayedKalmanFilter.jl's internal functions.","category":"page"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"See the Public Documentation section for documentation of the public interface.","category":"page"},{"location":"lib/internals/#Index","page":"Internals","title":"Index","text":"","category":"section"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"Pages = [\"internals.md\"]","category":"page"},{"location":"lib/internals/#Internal-Interface","page":"Internals","title":"Internal Interface","text":"","category":"section"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"Modules = [DelayedKalmanFilter]\nPublic = false\nPrivate = true","category":"page"},{"location":"lib/internals/#DelayedKalmanFilter.calculate_current_number_of_states-Tuple{AbstractFloat, DelayedKalmanFilter.TimeConstructor, AbstractFloat}","page":"Internals","title":"DelayedKalmanFilter.calculate_current_number_of_states","text":"Calculate the current number of states for a given observation time\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#DelayedKalmanFilter.calculate_final_covariance_matrix-NTuple{4, Any}","page":"Internals","title":"DelayedKalmanFilter.calculate_final_covariance_matrix","text":"Return the covariance matrix at the current (last predicted) number of states\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#DelayedKalmanFilter.calculate_steady_state_of_ode-Tuple{Any}","page":"Internals","title":"DelayedKalmanFilter.calculate_steady_state_of_ode","text":"Calculate the steady state of the Hes5 ODE system, for a specific set of parameters.\n\nArguments\n\nP₀::Float64\nh::Float64\nμₘ::Float64\nμₚ::Float64\nαₘ::Float64\nαₚ::Float64\n\nReturns\n\nsteady_state_solution::Array{Float64,1}: A 2-element array, giving the steady state for the mRNA and protein respectively.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#DelayedKalmanFilter.distribution_prediction_at_given_time-Tuple{Any, Any, Any, DelayedKalmanFilter.TimeConstructor, Integer, Matrix{<:AbstractFloat}, AbstractFloat}","page":"Internals","title":"DelayedKalmanFilter.distribution_prediction_at_given_time","text":"Calculate the mean and variance of the Normal approximation of the state space for a given time point in the Kalman filtering algorithm and return it as a Normal distribution\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#DelayedKalmanFilter.hes_ode!-NTuple{4, Any}","page":"Internals","title":"DelayedKalmanFilter.hes_ode!","text":"Function which defines the HES5 ode system\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#DelayedKalmanFilter.hill_function-Tuple{Any, Any, Any}","page":"Internals","title":"DelayedKalmanFilter.hill_function","text":"Calculate the Hill function for a given protein molecule number, repression threshold, and hill coefficient.\n\nArguments\n\nprotein::Real\nP₀::Real\nh::Real\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#DelayedKalmanFilter.initialise_state_space_mean-Tuple{DelayedKalmanFilter.TimeConstructor, Any, Any}","page":"Internals","title":"DelayedKalmanFilter.initialise_state_space_mean","text":"Initialse the state space mean for a given set of time states and the ODE system's steady state\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#DelayedKalmanFilter.initialise_state_space_variance-Tuple{DelayedKalmanFilter.TimeConstructor, Any, Any}","page":"Internals","title":"DelayedKalmanFilter.initialise_state_space_variance","text":"Initialse the state space variance for a given set of time states and the ODE system's steady state\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#DelayedKalmanFilter.kalman_filter_state_space_initialisation","page":"Internals","title":"DelayedKalmanFilter.kalman_filter_state_space_initialisation","text":"A function for initialisation of the state space mean and variance, and update for the \"negative\" times that are a result of the time delay. Initialises the negative times using the steady state of the deterministic system, and then updates them with kalmanupdatestep.\n\nArguments\n\nprotein_at_observations::AbstractArray{<:Real}: Observed protein. The dimension is n x 2, where n is the number of observation time points.   The first column is the time, and the second column is the observed protein copy number at   that time. The filter assumes that observations are generated with a fixed, regular time interval.\nmodel_parameters::ModelParameters: A ModelParameters object containing the model parameters in the following order:   repression threshold, hill coefficient, mRNA degradation rate,protein degradation rate, basal transcription rate,   translation rate, time delay.\nstates::TimeConstructor: A TimeConstructor whose fields define various values relevant to number of states, e.g. discretedelay,   totalnumberofstates, etc.\nobservation_transform: A 1 x 2 matrix corresponding to the transformation from observed data to molecule number, for mRNA and protein   respectively.\nmeasurement_variance::Real: The variance in our measurement. This is given by Sigma epsilon in Calderazzo et. al. (2018).\n\nReturns\n\nstate_space_mean::Matrix{<:AbstractFloat}: An N x 3 matrix, where N is the total number of states. The columns are time, mRNA   and protein respectively.\nstate_space_variance::Matrix{<:AbstractFloat}: An 2N x 2N matrix where N is the total number of states. It is constructed as a 2 x 2 block   matrix, where the blocks give the covariance of (mRNA, mRNA), (mRNA, protein), (protein, mRNA), and (protein, protein) for all times (t,s) where   abs(t -s) <= τ, the transcriptional time delay.\npredicted_observation_distributions::Array{Normal{Float64}}: An array of length n, whose entries are Normal distributions with mean and variance   equal to the state space mean and variance predictions for the corresponding time point.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#DelayedKalmanFilter.kalman_prediction_step!-Tuple{Any, Any, Any, DelayedKalmanFilter.TimeConstructor, Vector{<:AbstractFloat}, Vector{<:AbstractFloat}}","page":"Internals","title":"DelayedKalmanFilter.kalman_prediction_step!","text":"Perform the Kalman filter prediction about future observation, based on current knowledge i.e. current state space mean and variance. This gives rho{t+delta t-tau:t+delta t} and P{t+delta t-tau:t+delta t}, using the differential equations in supplementary section 4 of Calderazzo et al., Bioinformatics (2018), approximated using a forward Euler scheme.\n\nArguments\n\nstate_space_mean::Matrix{<:AbstractFloat}: An N x 3 matrix, where N is the total number of states. The columns are time, mRNA   and protein respectively.\nstate_space_variance::Matrix{<:AbstractFloat}: An 2N x 2N matrix where N is the total number of states. It is constructed as a 2 x 2 block   matrix, where the blocks give the covariance of (mRNA, mRNA), (mRNA, protein), (protein, mRNA), and (protein, protein) for all times (t,s) where   abs(t -s) <= τ, the transcriptional time delay.\nstates::TimeConstructor: A TimeConstructor whose fields define various values relevant to number of states, e.g. discretedelay,   totalnumberofstates, etc.\ncurrent_observation::Vector{<:AbstractFloat}: The current time point and protein observation which acts as the initial condition for the   prediction.\nmodel_parameters::ModelParameters: A ModelParameters object containing the model parameters in the following order:   repression threshold, hill coefficient, mRNA degradation rate,protein degradation rate, basal transcription rate,   translation rate, time delay.\n\nReturns\n\nstate_space_mean::Matrix{<:AbstractFloat}: An N x 3 matrix, where N is the total number of states. The columns are time, mRNA   and protein respectively. With each prediction new values are saved to the relevant entries in the matrix.\nstate_space_variance::Matrix{<:AbstractFloat}: An 2N x 2N matrix where N is the total number of states. It is constructed as a 2 x 2 block   matrix, where the blocks give the covariance of (mRNA, mRNA), (mRNA, protein), (protein, mRNA), and (protein, protein) for all times (t,s) where   abs(t -s) <= τ, the transcriptional time delay. With each prediction new values are saved to the relevant entries in the matrix.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#DelayedKalmanFilter.kalman_update_step!-Tuple{Any, Any, Any, DelayedKalmanFilter.TimeConstructor, Vector{<:AbstractFloat}, AbstractFloat, AbstractFloat, Any}","page":"Internals","title":"DelayedKalmanFilter.kalman_update_step!","text":"Perform the Kalman filter update step on the predicted mean and variance, given a new observation. This implements the equations at the beginning of page 4 in Calderazzo et al., Bioinformatics (2018). This assumes that the observations are collected at fixed time intervals.\n\nArguments\n\nstate_space_mean::Matrix{<:AbstractFloat}: An N x 3 matrix, where N is the total number of states. The columns are time, mRNA   and protein respectively.\nstate_space_variance::Matrix{<:AbstractFloat}: An 2N x 2N matrix where N is the total number of states. It is constructed as a 2 x 2 block   matrix, where the blocks give the covariance of (mRNA, mRNA), (mRNA, protein), (protein, mRNA), and (protein, protein) for all times (t,s) where   abs(t -s) <= τ, the transcriptional time delay.\nstates::TimeConstructor: A TimeConstructor whose fields define various values relevant to number of states, e.g. discretedelay,   totalnumberofstates, etc.\ncurrent_observation::Vector{<:AbstractFloat}: The current time point and protein observation which acts as the initial condition for the   prediction.\nτ::Real: The time delay parameter, model_parameters[7].\nmeasurement_variance::Real: The variance which defines the measurement error, it is Σ_ϵ in the equation y = Fx + Σ_ϵ.\n\nReturns\n\nstate_space_mean::Matrix{<:AbstractFloat}: An N x 3 matrix, where N is the total number of states. The columns are time, mRNA   and protein respectively. At each update step the relevant entries in the matrix are updated according to the update defined in   Calderazzo et al., Bioinformatics (2018).\nstate_space_variance::Matrix{<:AbstractFloat}: An 2N x 2N matrix where N is the total number of states. It is constructed as a 2 x 2 block   matrix, where the blocks give the covariance of (mRNA, mRNA), (mRNA, protein), (protein, mRNA), and (protein, protein) for all times (t,s) where   abs(t -s) <= τ, the transcriptional time delay. At each update step the relevant entries in the matrix are updated according to the update defined in   Calderazzo et al., Bioinformatics (2018).\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#DelayedKalmanFilter.predict_state_space_mean!-NTuple{4, Any}","page":"Internals","title":"DelayedKalmanFilter.predict_state_space_mean!","text":"Predict state space mean to the next observation time index\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#DelayedKalmanFilter.predict_state_space_variance!-NTuple{7, Any}","page":"Internals","title":"DelayedKalmanFilter.predict_state_space_variance!","text":"Predict state space variance to the next observation time index. There are three separate steps in the variance prediction:     (1) integrate P(t,s) to P(t+nΔt,s) for s = t-τ:t, where nΔt is the number of hidden         states. (horizontal/vertical)     (2) Integrate P(t,t) to P(t+nΔt,t+nΔt). (diagonal)     (3) Integrate P(t,t) to P(t,t+nΔt) for t in t:t+nΔt-1. (horizontal/vertical)\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#DelayedKalmanFilter.state_space_mean_indexer-NTuple{4, Any}","page":"Internals","title":"DelayedKalmanFilter.state_space_mean_indexer","text":"Helper function to return the state space mean for a given (real valued) time between t-τ and t+Δobs, where t is the current number of states.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#DelayedKalmanFilter.state_space_variance_indexer-NTuple{5, Any}","page":"Internals","title":"DelayedKalmanFilter.state_space_variance_indexer","text":"Helper function to return the state space variance for two given (real valued) times t₁ and t₂, between t-τ and t+Δobs, where t is the current number of states.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#DelayedKalmanFilter.time_constructor_function","page":"Internals","title":"DelayedKalmanFilter.time_constructor_function","text":"Function which returns an instance of TimeConstructor, which is defines the numbers of states for various uses in the Kalman filter.\n\n\n\n\n\n","category":"function"},{"location":"examples/tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"The package exports two functions, kalman_filter and calculate_log_likelihood_at_parameter_point.","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"Let's load some colours from Paul Tol and the Plots package for plotting.","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"using Plots\n\nbegin\n    black = RGBA{Float64}(colorant\"#000000\")\n    TolVibrantOrange = RGBA{Float64}(colorant\"#EE7733\")\n    TolVibrantBlue = RGBA{Float64}(colorant\"#0077BB\")\n    TolVibrantMagenta = RGBA{Float64}(colorant\"#EE3377\")\nend;","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"First we can simulate some observations. To do this, we define a stochastic delay differential equation problem using the StochasticDelayDiffEq.jl package.","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"using DelayedKalmanFilter, DifferentialEquations, StochasticDelayDiffEq, Statistics\n\nhillr(X, v, K, n) = v * (K^n) / (X^n + K^n)\n\nfunction hes_model_drift(du,u,h,p,t)\n    P₀, n, μₘ, μₚ, αₘ, αₚ, τ = p\n    du[1] = hillr(h(p,t-τ;idxs=2),αₘ,P₀,n) - μₘ*u[1]\n    du[2] = αₚ*u[1] - μₚ*u[2]\nend\n\nfunction hes_model_noise(du,u,h,p,t)\n    P₀, n, μₘ, μₚ, αₘ, αₚ, τ = p\n    du[1] = sqrt(max(0.,hillr(h(p,t-τ;idxs=2),αₘ,P₀,n) + μₘ*u[1]))\n    du[2] = sqrt(max(0.,αₚ*u[1] + μₚ*u[2]))\nend\n\nh(p, t; idxs::Int) = 1.0;","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"We use a chemical Langevin equation to simulate our SDDE system, as can be seen from the definition of the noise function[Gillespie2000].","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"[Gillespie2000]: Daniel T. Gillespie (2000). The chemical Langevin equation. J. Chem. Phys., Volume 113, Issue 297, 21 June 2000. https://doi.org/10.1063/1.481811.","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"We choose a specific set of parameters and solve the SciMLBase.SDDEProblem, then plot the protein from unobserved_data, as well as the noisy protein_observations.","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"p = [3407.99, 5.17, log(2)/30, log(2)/90, 15.86, 1.27, 30.];\ntspan=(0.,1720.);\n\nprob = SDDEProblem(hes_model_drift, hes_model_noise, [30.,500.], h, tspan, p; saveat=10);\nsol = solve(prob,RKMilCommute());\n\nunobserved_data = Array(sol)[:,100:end];\nmeasurement_std = 0.1*mean(unobserved_data[2,:])\n\nprotein = unobserved_data[2,:] + \n    measurement_std*randn(length(unobserved_data[2,:]));\n\ntimes = 0:10:730\nprotein_observations = hcat(times,protein)\n\n# unobserved protein\nplot(times, unobserved_data[2,:],\n    label=\"Unobserved\",\n    xlabel=\"Time (mins)\",\n    ylabel=\"Protein (molecule number)\",\n    linewidth=2,\n    color=TolVibrantBlue)\n# observed protein\nscatter!(times,protein_observations[:,2],\n    label=\"Observed\",\n    color=TolVibrantOrange)","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"Now we can call kalman_filter to get a state space mean and variance for each observation time point:","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"_, _, _, distributions = kalman_filter(protein_observations, p, measurement_std^2);\nmeans = [distributions[i].μ for i in 1:length(distributions)];\nstds = [distributions[i].σ for i in 1:length(distributions)];\n\n# unobserved protein\nplot(times, unobserved_data[2,:],\n    label=\"Unobserved\",\n    xlabel=\"Time (mins)\",\n    ylabel=\"Protein (molecule number)\",\n    linewidth=2,\n    color=TolVibrantBlue)\n\n# kalman mean and sd\nplot!(times,means,ribbon=stds,fillalpha=.1,\n    label=\"Kalman\",\n    linewidth=2,\n    color=TolVibrantMagenta)\n\n# observed protein\nscatter!(times,protein_observations[:,2],\n    label=\"Observed\",\n    color=TolVibrantOrange)","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"We can also use the convenience function calculate_log_likelihood_at_parameter_point to get a log-likelihood value for this specific (ground truth) parameter set.","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"calculate_log_likelihood_at_parameter_point(protein_observations, p, measurement_std^2)","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"Using a different parameter set should give us a smaller value for the likelihood.","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"p_wrong = [2407.57, 3.4, log(2)/30, log(2)/90, 5.6, 21.7, 12.];\ncalculate_log_likelihood_at_parameter_point(protein_observations, p_wrong, measurement_std^2)","category":"page"},{"location":"lib/public/#Public-Documentation","page":"Public","title":"Public Documentation","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"Documentation for DelayedKalmanFilter.jl's public interface.","category":"page"},{"location":"lib/public/","page":"Public","title":"Public","text":"See the Internals section for documentation of internal functions.","category":"page"},{"location":"lib/public/#Index","page":"Public","title":"Index","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"Pages = [\"public.md\"]","category":"page"},{"location":"lib/public/#Public-Interface","page":"Public","title":"Public Interface","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"calculate_log_likelihood_at_parameter_point\nkalman_filter","category":"page"},{"location":"lib/public/#DelayedKalmanFilter.calculate_log_likelihood_at_parameter_point","page":"Public","title":"DelayedKalmanFilter.calculate_log_likelihood_at_parameter_point","text":"Calculates the log likelihood of our data given the parameters, using a delay adjusted extended Kalman filter. It uses the predicted_observation_distributions from the kalman_filter function. The entries of this array in the second and third columns represent the probability of the future observation of mRNA and protein respectively, given our current knowledge.\n\nParameters\n\nprotein_at_observations::Matrix{<:AbstractFloat}: Observed protein. The dimension is N x 2, where N is the   number of observation time points. For each data set, the first column is the time,   and the second column is the observed protein copy number at that time.\nmodel_parameters::Vector{<:AbstractFloat}: An array containing the model parameters in the   following order: P₀, h, μₘ, μₚ, αₘ, αₚ, τ.\nmeasurement_variance::Float: The variance in our measurement. This is given by Σ_ϵ Sigma_e in Calderazzo et. al. (2018).\n\nReturns\n\nlog_likelihood::AbstractFloat.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#DelayedKalmanFilter.kalman_filter","page":"Public","title":"DelayedKalmanFilter.kalman_filter","text":"kalman_filter(\n    protein_at_observations::Matrix{<:AbstractFloat},\n    model_parameters::Vector{<:AbstractFloat},\n    measurement_variance::AbstractFloat,\n)\n\nA Kalman filter for a delay-adjusted non-linear stochastic process, based on observation of protein copy numbers. This implements the filter described by Calderazzo et al., Bioinformatics (2018).\n\nArguments\n\nprotein_at_observations::Matrix{<:AbstractFloat}: Observed protein. The dimension is N x 2, where N is the number of observation time points.   The first column is the time, and the second column is the observed protein copy number. The filter assumes that observations are generated with a fixed, regular time interval.\nmodel_parameters::Vector{<:AbstractFloat}: A vector containing the model parameters in the following order:   repression threshold (P₀), hill coefficient (h), mRNA degradation rate (μₘ), protein degradation rate (μₚ), basal transcription rate (αₘ),   translation rate (αₚ), and time delay (τ).\nmeasurement_variance::AbstractFloat: The variance in our measurement. This is given by Σ_ϵ in Calderazzo et. al. (2018).\n\nReturns\n\nstate_space_mean::Matrix{<:AbstractFloat}: An N x 3 matrix, where N is the total number of states. The columns are time, mRNA   and protein respectively.\nstate_space_variance::Matrix{<:AbstractFloat}: An 2N x 2N matrix where N is the total number of states. It is constructed as a 2 x 2 block   matrix, where the blocks give the covariance of (mRNA, mRNA), (mRNA, protein), (protein, mRNA), and (protein, protein) for all times (t,s) where   abs(t -s) <= τ, the transcriptional time delay.\npredicted_observation_distributions::Array{Normal{Float64}}: An array of length N, whose entries are Normal distributions with mean and variance   equal to the state space mean and variance predictions for the corresponding time point.\n\nExample\n\njulia> using DelayedKalmanFilter\n\njulia> protein = [0. 105.; 10. 100.; 20. 98.]; # times are 0., 10., 20., and protein levels are 105., 100., and 98. respectively\n\njulia> model_parameters = [100.0, 5.0, 0.1, 0.1, 1.0, 1.0, 15.0];\n\njulia> measurement_variance = 1000.0;\n\njulia> ss_mean, ss_var, _, distributions = kalman_filter(\n           protein,\n           model_parameters,\n           measurement_variance\n       );\n\njulia> distributions[1]\nDistributions.Normal{Float64}(μ=77.80895986786031, σ=93.7064351407417)\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = DelayedKalmanFilter","category":"page"},{"location":"#DelayedKalmanFilter.jl:-Approximate-likelihood-for-delayed-SDE's","page":"Home","title":"DelayedKalmanFilter.jl: Approximate likelihood for delayed SDE's","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package calculates an approximate likelihood function for the delayed stochastic differential equations","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginaligned\nfractextdmtextdt = alpha_mf(p(t-tau)) - mu_mm + sqrtalpha_mf(p(t-tau)) + mu_mmxi_m06em\nfractextdptextdt = alpha_pm - mu_pp + sqrtalpha_pm + mu_ppxi_p\nendaligned","category":"page"},{"location":"","page":"Home","title":"Home","text":"with data y_t defined under the observation process","category":"page"},{"location":"","page":"Home","title":"Home","text":"y_t = F x_t + epsilon_t","category":"page"},{"location":"","page":"Home","title":"Home","text":"where F is a 1 times 2 matrix, epsilon_t simmathcalN(0Sigma_epsilon) and Sigma_epsilon in mathbbR.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The function f is a repressive Hill function,","category":"page"},{"location":"","page":"Home","title":"Home","text":"f(p(t-tau)) = frac11 + p(t-tau)P_0^h","category":"page"},{"location":"","page":"Home","title":"Home","text":"and xi_m and xi_p are temporally uncorrelated, statistically independent Gaussian white noises.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Using a delay adjusted extended Kalman filter, we seek to define an approximate likelihood function","category":"page"},{"location":"","page":"Home","title":"Home","text":"pi(mathbfymidboldsymboltheta)","category":"page"},{"location":"","page":"Home","title":"Home","text":"where boldsymboltheta defines the parameters of the system.[Calderazzo2019][Burton2021].","category":"page"},{"location":"","page":"Home","title":"Home","text":"[Calderazzo2019]: Silvia Calderazzo, Marco Brancaccio, and Bärbel Finkenstädt (2018). Filtering and inference for stochastic oscillators with distributed delays. Bioinformatics, Volume 35, Issue 8, 15 April 2019. https://doi.org/10.1093/bioinformatics/bty782.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[Burton2021]: Joshua Burton, Cerys S. Manning Magnus Rattray, Nancy Papalopulu, and Jochen Kursawe (2021). Inferring kinetic parameters of oscillatory gene regulation from single cell time-series data. J. R. Soc. Interface, Volume 18, Issue 182, 29 September 2021. http://doi.org/10.1098/rsif.2021.0393.","category":"page"}]
}
