var documenterSearchIndex = {"docs":
[{"location":"lib/internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"Documentation for DelayedKalmanFilter.jl's internal functions.","category":"page"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"See the Public Documentation section for documentation of the public interface.","category":"page"},{"location":"lib/internals/#Index","page":"Internals","title":"Index","text":"","category":"section"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"Pages = [\"internals.md\"]","category":"page"},{"location":"lib/internals/#Internal-Interface","page":"Internals","title":"Internal Interface","text":"","category":"section"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"Modules = [DelayedKalmanFilter]\nPublic = false\nPrivate = true","category":"page"},{"location":"lib/internals/#DelayedKalmanFilter.SolutionObject-Tuple{Any}","page":"Internals","title":"DelayedKalmanFilter.SolutionObject","text":"Defines a method for SolutionObject variables, which interrogates the at_time function at time t\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#DelayedKalmanFilter.calculate_steady_state_of_ode-Tuple{Any}","page":"Internals","title":"DelayedKalmanFilter.calculate_steady_state_of_ode","text":"Calculate the steady state of the Hes5 ODE system, for a specific set of parameters.\n\nArguments\n\nP₀::AbstractFloat\nh::AbstractFloat\nμₘ::AbstractFloat\nμₚ::AbstractFloat\nαₘ::AbstractFloat\nαₚ::AbstractFloat\n\nReturns\n\nsteady_state_solution::Array{AbstractFloat,1}: A 2-element array, giving the steady state for the mRNA and protein respectively.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#DelayedKalmanFilter.distribution_prediction-Union{Tuple{T}, Tuple{DelayedKalmanFilter.SystemState, Matrix{T}, T}} where T<:AbstractFloat","page":"Internals","title":"DelayedKalmanFilter.distribution_prediction","text":"Calculate the mean and standard deviation of the Normal approximation of the state space for a given time point in the Kalman filtering algorithm and return it as an array.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#DelayedKalmanFilter.hes_ode!-NTuple{4, Any}","page":"Internals","title":"DelayedKalmanFilter.hes_ode!","text":"Function which defines the HES5 ode system\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#DelayedKalmanFilter.hill_function-Tuple{Any, Any, Any}","page":"Internals","title":"DelayedKalmanFilter.hill_function","text":"Calculate the Hill function for a given protein molecule number, repression threshold, and hill coefficient.\n\nArguments\n\nprotein::AbstractFloat\nP₀::AbstractFloat\nh::AbstractFloat\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#DelayedKalmanFilter.initialise_off_diagonals-Tuple{Any, Any, Any}","page":"Internals","title":"DelayedKalmanFilter.initialise_off_diagonals","text":"Initialse the off diagonals for a given set of time states and the ODE system's steady state\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#DelayedKalmanFilter.initialise_state_space_mean-Tuple{Any, Any}","page":"Internals","title":"DelayedKalmanFilter.initialise_state_space_mean","text":"Initialise the state space mean for a given set of time states and the ODE system's steady state\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#DelayedKalmanFilter.initialise_state_space_variance-Tuple{Any, Any}","page":"Internals","title":"DelayedKalmanFilter.initialise_state_space_variance","text":"Initialse the state space variance for a given set of time states and the ODE system's steady state\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#DelayedKalmanFilter.kalman_filter_state_space_initialisation-Union{Tuple{T}, Tuple{Matrix{T}, Any, Matrix{T}, T, Integer}} where T","page":"Internals","title":"DelayedKalmanFilter.kalman_filter_state_space_initialisation","text":"A function for initialisation of the state space mean and variance, and update for the \"negative\" times that are a result of the time delay. Initialises the negative times using the steady state of the deterministic system, and then updates them with kalmanupdatestep.\n\nArguments\n\nprotein_at_observations: Observed protein. The dimension is n x 2, where n is the number of observation time points.   The first column is the time, and the second column is the observed protein copy number at   that time. The filter assumes that observations are generated with a fixed, regular time interval.\nmodel_parameters: An array containing the model parameters in the following order:   repression threshold, hill coefficient, mRNA degradation rate,protein degradation rate, basal transcription rate,   translation rate, time delay.\nobservation_transform: A 1 x 2 matrix corresponding to the transformation from ob\n\nserved data to molecule number, for mRNA and protein     respectively.\n\nmeasurement_variance: The variance in our measurement. This is given by Sigma epsilon in Calderazzo et. al. (2018).\n\nReturns\n\nsystem_state::SystemState:\npredicted_observation_distributions::Matrix{Float64}: A matrix of size N x 2. The entries in the first column are the predicted state\n\nspace mean and the entries in the second column are the predicted state space variance for each observation.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#DelayedKalmanFilter.kalman_prediction_step!-Tuple{Any, Any, Any}","page":"Internals","title":"DelayedKalmanFilter.kalman_prediction_step!","text":"Perform the Kalman filter prediction about future observation, based on current knowledge i.e. current state space mean and variance. This gives rho{t+Δt-τ:t+Δt} and P{t+Δt-τ:t+Δt}, using the differential equations in supplementary section 4 of Calderazzo et al., Bioinformatics (2018), approximated using a forward Euler scheme.\n\nArguments\n\nsystem_state::SystemState:\nmodel_parameters: An array containing the model parameters in the following order:   repression threshold, hill coefficient, mRNA degradation rate,protein degradation rate, basal transcription rate,   translation rate, time delay.\n\nReturns\n\nsystem_state::SystemState\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#DelayedKalmanFilter.kalman_update_step!-Tuple{Any, Any, Any}","page":"Internals","title":"DelayedKalmanFilter.kalman_update_step!","text":"Perform the Kalman filter update step on the predicted mean and variance, given a new observation. This implements the equations at the beginning of page 4 in Calderazzo et al., Bioinformatics (2018). This assumes that the observations are collected at fixed time intervals.\n\nArguments\n\nsystem_state::SystemState\nmeasurement_variance: The variance which defines the measurement error, it is Σ_ϵ in the equation y = Fx + Σ_ϵ.\nobservation_transform: A 1 x 2 matrix corresponding to the transformation from observed data to molecule number, for mRNA and protein\n\nrespectively.\n\nReturns\n\nsystem_state::SystemState\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#DelayedKalmanFilter.predict_state_space_mean!-Tuple{Any, Any}","page":"Internals","title":"DelayedKalmanFilter.predict_state_space_mean!","text":"Predict state space mean to the next observation time index\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#DelayedKalmanFilter.predict_variance_and_off_diagonals!-Tuple{Any, Any}","page":"Internals","title":"DelayedKalmanFilter.predict_variance_and_off_diagonals!","text":"Predict state space variance to the next observation time index. There are three separate steps in the variance prediction:     (1) integrate P(t,s) to P(t+nΔt,s) for s = t-τ:t, where nΔt is the number of hidden         states. (propagateexistingoffdiagonals!())     (2) Integrate P(t,t) to P(t+nΔt,t+nΔt). (propagatevariance!())     (3) Integrate P(t,t) to P(t,t+nΔt) for t in t:t+nΔt-1. (propagatenewoff_diagonals!())\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#DelayedKalmanFilter.update_current_time_and_observation!-Union{Tuple{T}, Tuple{DelayedKalmanFilter.SystemState, T}} where T<:Integer","page":"Internals","title":"DelayedKalmanFilter.update_current_time_and_observation!","text":"Update the current time and observation of the system state\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#DelayedKalmanFilter.updatefunc-Tuple{Any, Any}","page":"Internals","title":"DelayedKalmanFilter.updatefunc","text":"Return a new function whose return value is the sum of the return values of the function old and the function update\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#DelayedKalmanFilter.∂hill∂p-Tuple{Any, Any, Any}","page":"Internals","title":"DelayedKalmanFilter.∂hill∂p","text":"The partial derivative of the Hill function with respect to the protein molecule number.\n\nArguments\n\nprotein::AbstractFloat\nP₀::AbstractFloat\nh::AbstractFloat\n\n\n\n\n\n","category":"method"},{"location":"examples/parameter-estimation/#Parameter-Estimation","page":"Parameter Estimation","title":"Parameter Estimation","text":"","category":"section"},{"location":"examples/parameter-estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"Some intro into doing parameter estimation","category":"page"},{"location":"examples/parameter-estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"Let's use the same data set from the Tutorial:","category":"page"},{"location":"examples/parameter-estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"using Plots, Random\nRandom.seed!(25)\n\nbegin\n    black = RGBA{Float64}(colorant\"#000000\")\n    TolVibrantOrange = RGBA{Float64}(colorant\"#EE7733\")\n    TolVibrantBlue = RGBA{Float64}(colorant\"#0077BB\")\n    TolVibrantMagenta = RGBA{Float64}(colorant\"#EE3377\")\nend;\n\nusing DelayedKalmanFilter, StochasticDelayDiffEq, Statistics\n\nhillr(X, v, K, n) = v * (K^n) / (X^n + K^n)\n\nfunction hes_model_drift(du,u,h,p,t)\n    P₀, n, μₘ, μₚ, αₘ, αₚ, τ = p\n    du[1] = hillr(h(p,t-τ;idxs=2),αₘ,P₀,n) - μₘ*u[1]\n    du[2] = αₚ*u[1] - μₚ*u[2]\nend\n\nfunction hes_model_noise(du,u,h,p,t)\n    P₀, n, μₘ, μₚ, αₘ, αₚ, τ = p\n    du[1] = sqrt(max(0.,hillr(h(p,t-τ;idxs=2),αₘ,P₀,n) + μₘ*u[1]))\n    du[2] = sqrt(max(0.,αₚ*u[1] + μₚ*u[2]))\nend\n\nh(p, t; idxs::Int) = 1.0;\n\np = [3407.99, 5.17, log(2)/30, log(2)/90, 15.86, 1.27, 30.];\ntspan=(0.,1720.);\n\nprob = SDDEProblem(hes_model_drift, hes_model_noise, [30.,500.], h, tspan, p; saveat=10);\nsol = solve(prob,RKMilCommute());\n\nunobserved_data = Array(sol)[:,100:end];\nmeasurement_std = 0.1*mean(unobserved_data[2,:])\n\nprotein = unobserved_data[2,:] + \n    measurement_std*randn(length(unobserved_data[2,:]));\n\ntimes = 0:10:730\nprotein_observations = hcat(times,protein)\n\n# unobserved protein\nplot(\n    times,\n    unobserved_data[2,:],\n    label=\"Unobserved\",\n    linewidth=2,\n    color=TolVibrantBlue)\n\n# observed protein\nscatter!(\n    times,\n    protein_observations[:,2],\n    label=\"Observed\",\n    color=TolVibrantOrange\n)\n\nplot!(xlabel=\"Time (minutes)\", ylabel=\"Protein molecule number\")","category":"page"},{"location":"examples/parameter-estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"Imagine we only have the data, and do not know the value of all the parameters of our model that generated this data. How can we determine their value?","category":"page"},{"location":"examples/parameter-estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"Let's first assume we know all values but one, in this case tau. A very simple approach would be to calculate the likelihood for a range of values for each parameter, and choose the most likely parameter value in this way. For example:","category":"page"},{"location":"examples/parameter-estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"time_delays = LinRange(1., 45., 50)\nmany_p = [[3407.99, 5.17, log(2)/30, log(2)/90, 15.86, 1.27, i] for i in time_delays]\nll_delays = [calculate_log_likelihood_at_parameter_point(protein_observations, p, measurement_std^2) for p in many_p]\n\nplot(time_delays, ll_delays)\nplot!(xlabel = \"τ\", ylabel = \"log-likelihood\")","category":"page"},{"location":"examples/parameter-estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"As the number of parameters we want to infer increases, this approach becomes less and less viable. We can instead make use of some more advanced algorithm's for maximum likelihood estimation.","category":"page"},{"location":"examples/parameter-estimation/#Model-definition","page":"Parameter Estimation","title":"Model definition","text":"","category":"section"},{"location":"examples/parameter-estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"Something about probabilistic models, Turing allows us to define and work with them.","category":"page"},{"location":"examples/parameter-estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"using Turing, LinearAlgebra\n\n@model function infer_repression(data, times, repression_mean, measurement_variance)\n    P₀ ~ truncated(Normal(repression_mean, 500^2); lower=100., upper=repression_mean*2)\n    \n    _, distributions = kalman_filter(\n        hcat(times, data),\n        [P₀, 5.17, log(2)/30, log(2)/90, 15.86, 1.27, 30.],\n        measurement_variance\n    )\n    data ~ MvNormal(distributions[:,1], diagm(distributions[:,2]))\nend\n\nmodel = infer_repression(\n    protein_observations[:,2],\n    protein_observations[:,1],\n    mean(protein_observations[:,2]),\n    measurement_std^2\n)","category":"page"},{"location":"examples/parameter-estimation/#Maximum-likelihood-estimation","page":"Parameter Estimation","title":"Maximum likelihood estimation","text":"","category":"section"},{"location":"examples/parameter-estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"using Optimization.jl we can take a Turing model and perform MLE.","category":"page"},{"location":"examples/parameter-estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"using Optim\nmle_estimate = optimize(model, MLE())","category":"page"},{"location":"examples/parameter-estimation/#Pathfinder-and-HMC","page":"Parameter Estimation","title":"Pathfinder and HMC","text":"","category":"section"},{"location":"examples/parameter-estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"Initialise with Pathfinder, do some sampling with NUTS(0.8).","category":"page"},{"location":"examples/tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"The package exports two functions, kalman_filter and calculate_log_likelihood_at_parameter_point.","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"Let's load some colours from Paul Tol and the Plots package for plotting.","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"using Plots, Random\nRandom.seed!(25)\n\nbegin\n    black = RGBA{Float64}(colorant\"#000000\")\n    TolVibrantOrange = RGBA{Float64}(colorant\"#EE7733\")\n    TolVibrantBlue = RGBA{Float64}(colorant\"#0077BB\")\n    TolVibrantMagenta = RGBA{Float64}(colorant\"#EE3377\")\nend;\nnothing # hide","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"First we can simulate some observations. To do this, we define a stochastic delay differential equation problem using the StochasticDelayDiffEq.jl package.","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"using DelayedKalmanFilter, StochasticDelayDiffEq, Statistics\n\nhillr(X, v, K, n) = v * (K^n) / (X^n + K^n)\n\nfunction hes_model_drift(du,u,h,p,t)\n    P₀, n, μₘ, μₚ, αₘ, αₚ, τ = p\n    du[1] = hillr(h(p,t-τ;idxs=2),αₘ,P₀,n) - μₘ*u[1]\n    du[2] = αₚ*u[1] - μₚ*u[2]\nend\n\nfunction hes_model_noise(du,u,h,p,t)\n    P₀, n, μₘ, μₚ, αₘ, αₚ, τ = p\n    du[1] = sqrt(max(0.,hillr(h(p,t-τ;idxs=2),αₘ,P₀,n) + μₘ*u[1]))\n    du[2] = sqrt(max(0.,αₚ*u[1] + μₚ*u[2]))\nend\n\nh(p, t; idxs::Int) = 1.0;\nnothing # hide","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"We use a chemical Langevin equation to simulate our SDDE system, as can be seen from the definition of the noise function[Gillespie2000].","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"[Gillespie2000]: Daniel T. Gillespie (2000). The chemical Langevin equation. J. Chem. Phys., Volume 113, Issue 297, 21 June 2000. https://doi.org/10.1063/1.481811.","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"We choose a specific set of parameters and solve the SciMLBase.SDDEProblem, then plot the protein from unobserved_data, as well as the noisy protein_observations.","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"p = [3407.99, 5.17, log(2)/30, log(2)/90, 15.86, 1.27, 30.];\ntspan=(0.,1720.);\n\nprob = SDDEProblem(hes_model_drift, hes_model_noise, [30.,500.], h, tspan, p; saveat=10);\nsol = solve(prob,RKMilCommute());\n\nunobserved_data = Array(sol)[:,100:end];\nmeasurement_std = 0.1*mean(unobserved_data[2,:])\n\nprotein = unobserved_data[2,:] + \n    measurement_std*randn(length(unobserved_data[2,:]));\n\ntimes = 0:10:730\nprotein_observations = hcat(times,protein)\n\n# unobserved protein\nplot(\n    times,\n    unobserved_data[2,:],\n    label=\"Unobserved\",\n    linewidth=2,\n    color=TolVibrantBlue)\n\n# observed protein\nscatter!(\n    times,\n    protein_observations[:,2],\n    label=\"Observed\",\n    color=TolVibrantOrange\n)\n\nplot!(xlabel=\"Time (minutes)\", ylabel=\"Protein molecule number\")","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"Now we can call kalman_filter to get a SystemState object, which we can use to obtain the state space mean and variance for each observation time point:","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"system_state, distributions = kalman_filter(protein_observations, p, measurement_std^2);\nmeans = [get_mean_at_time(i, system_state)[2] for i in times];\nstds = [sqrt(get_variance_at_time(i, system_state)[2,2]+measurement_std^2) for i in times];\n\nplot(\n    times,\n    unobserved_data[2,:],\n    label=\"Unobserved\",\n    linewidth=2,\n    color=TolVibrantBlue\n)\n\nscatter!(times, protein_observations[:,2], label=\"Observations\")\n\nplot!(\n    times,\n    means,\n    ribbon=stds,\n    fillalpha=.1,\n    label=\"Kalman filter (with 1SD and 2SD)\",\n    linewidth=2,\n    color=TolVibrantMagenta\n)\n\nplot!(\n    times,\n    means,\n    ribbon=2*stds,\n    fillalpha=.1,\n    label=false,\n    linewidth=2,\n    color=TolVibrantMagenta\n)\n\nplot!(xlabel=\"Time (minutes)\", ylabel=\"Protein molecule number\")","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"We can also use the convenience function calculate_log_likelihood_at_parameter_point to get a log-likelihood value for this specific (ground truth) parameter set.","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"calculate_log_likelihood_at_parameter_point(protein_observations, p, measurement_std^2)","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"Using a different parameter set should give us a smaller value for the log-likelihood.","category":"page"},{"location":"examples/tutorial/","page":"Tutorial","title":"Tutorial","text":"p_wrong = [2407.57, 3.4, log(2)/30, log(2)/90, 5.6, 21.7, 12.];\ncalculate_log_likelihood_at_parameter_point(protein_observations, p_wrong, measurement_std^2)","category":"page"},{"location":"lib/public/#Public-Documentation","page":"Public","title":"Public Documentation","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"Documentation for DelayedKalmanFilter.jl's public interface.","category":"page"},{"location":"lib/public/","page":"Public","title":"Public","text":"See the Internals section for documentation of internal functions.","category":"page"},{"location":"lib/public/#Index","page":"Public","title":"Index","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"Pages = [\"public.md\"]","category":"page"},{"location":"lib/public/#Public-Interface","page":"Public","title":"Public Interface","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"calculate_log_likelihood_at_parameter_point\nkalman_filter","category":"page"},{"location":"lib/public/#DelayedKalmanFilter.calculate_log_likelihood_at_parameter_point","page":"Public","title":"DelayedKalmanFilter.calculate_log_likelihood_at_parameter_point","text":"Calculates the log likelihood of our data given the parameters, using a delay adjusted extended Kalman filter. It uses the predicted_observation_distributions from the kalman_filter function. The entries of this array in the second and third columns represent the probability of the future observation of mRNA and protein respectively, given our current knowledge.\n\nParameters\n\nprotein_at_observations::Matrix{<:AbstractFloat}: Observed protein. The dimension is N x 2, where N is the   number of observation time points. For each data set, the first column is the time,   and the second column is the observed protein copy number at that time.\nmodel_parameters::Vector{<:AbstractFloat}: An array containing the model parameters in the   following order: P₀, h, μₘ, μₚ, αₘ, αₚ, τ.\nmeasurement_variance::Float: The variance in our measurement. This is given by Σ_ϵ Sigma_e in Calderazzo et. al. (2018).\n\nReturns\n\nlog_likelihood::AbstractFloat.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#DelayedKalmanFilter.kalman_filter","page":"Public","title":"DelayedKalmanFilter.kalman_filter","text":"kalman_filter(\n    protein_at_observations::Matrix{T},\n    model_parameters::Vector{T},\n    measurement_variance::T;\n    off_diagonal_steps::Integer = 10,\n) where T\n\nA Kalman filter for a delay-adjusted non-linear stochastic process, based on observation of protein copy numbers. This implements the filter described by Calderazzo et al., Bioinformatics (2018).\n\nArguments\n\nprotein_at_observations: Observed protein. The dimension is N x 2, where N is the number of observation time points.   The first column is the time, and the second column is the observed protein copy number. The filter assumes that observations are generated with a fixed, regular time interval.\nmodel_parameters: A vector containing the model parameters in the following order:   repression threshold (P₀), hill coefficient (h), mRNA degradation rate (μₘ), protein degradation rate (μₚ), basal transcription rate (αₘ),   translation rate (αₚ), and time delay (τ).\nmeasurement_variance: The variance in our measurement. This is given by Σ_ε  in Calderazzo et. al. (2018).\noff_diagonal_timestep: The number of off-diagonal time steps. This parameter determines how many DDE's   we need to solve in the predict_variance_and_off_diagonals! function.\n\nReturns\n\nsystem_state::SystemState: \npredicted_observation_distributions::Matrix{<:AbstractFloat}: A matrix of size N x 2. The entries in the first column are the predicted state\n\nspace mean and the entries in the second column are the predicted state space variance for each observation.\n\nExample\n\njulia> using DelayedKalmanFilter\n\njulia> protein = [0. 105.; 10. 100.; 20. 98.]; # times are 0., 10., 20., and protein levels are 105., 100., and 98. respectively\n\njulia> model_parameters = [300.0, 4.0, 0.1, 0.1, 1.0, 1.0, 15.0];\n\njulia> measurement_variance = 1000.0;\n\njulia> system_state, distributions = kalman_filter(\n           protein,\n           model_parameters,\n           measurement_variance\n       );\n\njulia> distributions[1,:]\n2-element Vector{Float64}:\n    98.83535976369208\n 10883.535976369209\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = DelayedKalmanFilter","category":"page"},{"location":"#DelayedKalmanFilter.jl:-Approximate-likelihood-for-delayed-SDE's","page":"Home","title":"DelayedKalmanFilter.jl: Approximate likelihood for delayed SDE's","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package calculates an approximate likelihood function for the delayed stochastic differential equations","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginaligned\nfractextdmtextdt = alpha_mf(p(t-tau)) - mu_mm + sqrtalpha_mf(p(t-tau)) + mu_mm xi_m06em\nfractextdptextdt = alpha_pm - mu_pp + sqrtalpha_pm + mu_pp xi_p\nendaligned","category":"page"},{"location":"","page":"Home","title":"Home","text":"with time-series data y_t defined under the observation process","category":"page"},{"location":"","page":"Home","title":"Home","text":"y_t = F x_t + epsilon_t","category":"page"},{"location":"","page":"Home","title":"Home","text":"where x_t = m(t) p(t)^T, F is a 1 times 2 matrix, epsilon_t simmathcalN(0Sigma_epsilon) and Sigma_epsilon in mathbbR.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The function f is a repressive Hill function,","category":"page"},{"location":"","page":"Home","title":"Home","text":"f(p(t-tau)) = frac11 + p(t-tau)P_0^h","category":"page"},{"location":"","page":"Home","title":"Home","text":"and xi_m and xi_p are temporally uncorrelated, statistically independent Gaussian white noises.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Using a delay adjusted extended Kalman filter, we seek to define an approximate likelihood function","category":"page"},{"location":"","page":"Home","title":"Home","text":"mathcalL(boldsymbolthetamidmathbfy)","category":"page"},{"location":"","page":"Home","title":"Home","text":"where boldsymboltheta defines the parameters of the system.[Calderazzo2019][Burton2021].","category":"page"},{"location":"","page":"Home","title":"Home","text":"With this function we can utilise either maximum likelihood estimation to obtain a point estimate","category":"page"},{"location":"","page":"Home","title":"Home","text":"hatboldsymboltheta = undersetboldsymbolthetaargmaxmathcalL(boldsymbolthetamidmathbfy)","category":"page"},{"location":"","page":"Home","title":"Home","text":"or Markov chain Monte Carlo (MCMC) methods to estimate a posterior distribution for the parameters of our model. See Parameter Estimation for details.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[Calderazzo2019]: Silvia Calderazzo, Marco Brancaccio, and Bärbel Finkenstädt (2018). Filtering and inference for stochastic oscillators with distributed delays. Bioinformatics, Volume 35, Issue 8, 15 April 2019. https://doi.org/10.1093/bioinformatics/bty782.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[Burton2021]: Joshua Burton, Cerys S. Manning Magnus Rattray, Nancy Papalopulu, and Jochen Kursawe (2021). Inferring kinetic parameters of oscillatory gene regulation from single cell time-series data. J. R. Soc. Interface, Volume 18, Issue 182, 29 September 2021. http://doi.org/10.1098/rsif.2021.0393.","category":"page"}]
}
